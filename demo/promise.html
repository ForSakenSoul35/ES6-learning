<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Promise</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

</head>
<body>
  <script>
    /*
      异步：
    */
    /*
      promise的作用
    */
    /*
      promise的基本用法
    */
    // {
    //   // 回调函数
    //   let ajax = function(callback){
    //     console.log('执行');
    //     setTimeout(function(){
    //       callback&&callback.call()
    //     },1000)
    //   };
    //   ajax(function(){
    //     console.log('timeout1')
    //   });
    //   // 回调地狱?
    //   // 使用promise实现
    //   {
    //     let ajax =function(){
    //       console.log('执行2');
    //       return new Promise(function(resolve,reject){
    //         setTimeout(function(){
    //           resolve()
    //         },1000);
    //       })
    //     }
    //     // ajax()返回的是一个promise实例
    //     ajax().then(function(){
    //       console.log("promise",'timeout2')
    //     })
    //   }
    //   // 多步调用
    //   {
    //     let ajax =function(){
    //       console.log('执行3');
    //       return new Promise(function(resolve,reject){
    //         setTimeout(function(){
    //           resolve()
    //         },1000);
    //       })
    //     }
    //     // ajax()返回的是一个promise实例
    //     ajax()
    //     .then(function(){
    //       return new Promise(function(resolve,reject){
    //         setTimeout(function(){
    //           resolve()
    //         },2000);
    //       });
    //     })
    //     .then(function(){
    //       console.log('timeout3')
    //     })
    //   }

    // }
    /*
    Promise 概念
      异步编程的一种解决方案 
      传统的解决方案  回调函数和绑定事件
      更合理 更强大
    
      Promise就是一个容器 里面保存着某个未来才会结束的事件 通常是一个异步操作
      是一个对象 从它可以获取异步操作的消息。
      提供统一的API 各种异步操作都可以用同样的方法 处理

      特点：
      1.对象的状态不受外界影响
      Promise 对象代表一个异步操作  三种状态
      pending 进行中 fufilled 已成功 rejected 已失败
      只有异步操作的结果可以决定当前是哪一种状态 任何其他操作都无法改变这个状态

      2. 一旦状态改变 就不会再变
        状态改变的可能:
          pending->fulfilled
          pending->rejected
          只要这两种情况发生，就不会再变了，会一直保持这个结果，这时就成为resolved
    */
    /*
    Promise 基本用法
    ES6规定 Promise对象是一个构造函数 用来生成Promise实例

    Promise构造函数接收一个函数作为参数，该函数的两个参数分别为resolve和rejecct 它们是两个参数
    由js引擎提供，不用自己部署

    resolve函数的作用是  将Promise对象的状态从 未完成 变为 成功 pending->resolved
      在异步操作成功时调用，并将异步操作的结果，作为参数传递出去
    reject函数的作用，将Promise对象的状态从 未完成 改为 失败 pending->rejectd
     在异步操作失败时调用，并将异步操作的报错的错误 作为参数传递出去

    Promise实例生成之后，可以用then方法 分别为resolved状态和rejected状态的回调函数
    
    */
    // {
    //   //生成Promise实例
    //   const promise = new Promise(function(resolve,reject){
    //     //code
    //     if(/*异步操作成功*/){
    //       resolve(value);
    //     }else{
    //       reject(error);
    //     }
    //   })
    // }
    // {
    //   //指定回调函数
    //   promise.then(function(value){
    //   //success
    // }),function(error){
    //   //failure
    // }
    // }

    // {
    //   function timeout(ms){
    //     return new Promise((resolve,reject)=>{
    //       // 返回一个Promise实例 
    //       setTimeout(resolve,ms,'done');
    //     });
    //   }
    //   timeout(100).then((value)=>{
    //     console.log(value);
    //   })

    // }
    {
      let promise = new Promise(function(resolve,reject){
        console.log("Promise");
        resolve();
      });
      promise.then(function(){
        console.log('resolved');

      });

      console.log('hi')

    }
    /*
      解决问题：
      1. 回调地狱
      2. 数据请求以及数据处理分离开
    */
    /*
    Promise 三种状态
    pending  等待中或者进行中
    resolved 已经完成  表示已经得到我们想要的结果 可以往下执行
    rejected 也表示得到结果 但结果不是我们想要的 因此拒绝执行
    注意：
    状态不受外界影响 不可逆
    */
    {
      new Promise(function(resolve,reject){
        if(true){resolve()};
        if(false){reject()};
        // resolve reject 都为一个函数 作用在于修改状态
      });
    }
    /*
    Promise 对象的then方法 可以接收构造函数中处理的状态变化 并分别对应执行。
    then方法有两个参数 第一个参数接收resolved状态的执行，第二个参数接收rejected状态的执行
    */
    {
      function fn(num){
        return new Promise(function(resolve,reject){
          if (typeof num == 'number'){
            reslove();
          }else{
            reject();
          }
        }).then(function(){
          console.log('参数是一个number值');
        }),function(){
          console.log('参数不是一个number值');
        }
      }
      fn('hahah');
      fn('123');
    }
    /*
    语法：
      new Promise(function(resolve,reject){

      })
      promise
    */
    {
      //异步加载图片
      function loadImageAsync(url){
        return new Promise(function(resolve,reject){
          const image = new Image();
          image.onload = function(){
            resolve(image);
          };
          image.onerror = function(){
            reject(new Error('Could not load image at'+url));
          };
          image.src =url;
        });
      }
    }
  </script>
</body>
</html>